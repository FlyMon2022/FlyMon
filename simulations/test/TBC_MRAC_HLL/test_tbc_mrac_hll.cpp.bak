
#include <unordered_map>
#include "tbc/tbc_manager.h"
#include "DataTrace.h"
#include "EMFSD.h"
#include "CommonFunc.h"
#include <fstream>
#include <ctime>
#include <bitset>


// #define FILE_MRAC_DSITRIBUTION "flow_distribution0.02.txt"  //1MB
const uint32_t TBC_NUM = 1;
const uint32_t BLOCK_NUM = 3;
const uint32_t SUB_BLOCK_NUM = 16;
const uint32_t m = 512;
const uint32_t n = 8192;
const int coin_level = 3; // 1/2
const double coff = 8;
const uint32_t BLOCK_SIZE = m * SUB_BLOCK_NUM;

using Manager = TBC_Manager<TBC_NUM, BLOCK_NUM, BLOCK_SIZE, SUB_BLOCK_NUM>;

double calc_alpha(const vector<double>& dist){
    double alpha = 0.0;
    double s = 1/coff;
    double total_size = 0;
    for(auto& x : dist) total_size += x;
    for(uint32_t i=0; i<dist.size(); ++i){
        uint32_t n = i;
        double p = dist[i] / total_size;
        alpha += p * (1-pow((1-s), n));
    } 
    return alpha;
}

uint32_t get_max(const unordered_map<string, int>& data){
    uint32_t max = 0;
    for(auto& item : data){
        if(item.second > max) 
        {
            max = item.second;
        }
    }
    return max;
}

long permutationsC(int a, int b){
    // sorry for the func num
    return tgamma(a+1) / (tgamma(b+1)*tgamma(a-b));
}

// the vector is too big to alloc, we should exchange time for space
// so there are many annotation in the code 
void recover_distribution_iteronce(vector<double>& distribution, double in_coff, int iter_num){
    // flows has pkts bigger than the upper bound will not included in the iteration
    const int upperbound = 20;
    const int sample_coefficient = static_cast<uint32_t>(in_coff);
    // good-turing
    distribution[0] = distribution[1]*2;
    // the recovered distribution
    vector<double> new_distribution(distribution.size() * sample_coefficient, 0);
    // the distribution involed in the iterations
    vector<double> iter_distribution(upperbound * sample_coefficient, 1 / (upperbound * in_coff));
    // the flows aren't included in the iteration
    // vector<pair<int, double>> bigger_flows();
    // the probability of flow containing n pkt being sampled as i pkt flow
    vector<vector<double>> probability_n_i(upperbound * sample_coefficient, vector<double>(upperbound));  
    // the fraction of i pkt flow in sample set
    vector<double> fraction_i(upperbound, 0);
    double s = 1/in_coff;  // sample rate
    long total_flow_num = 0;  // the total number of flows in the sample set
    long iter_flow_num = 0;  // the number of flows in iterations
    vector<double> factorial(upperbound * sample_coefficient, 0);
    
    // calc factorial
    factorial[0] = 1;
    for(int i = 1; i < upperbound * sample_coefficient; i++){
        factorial[i] = factorial[i-1] * i;
    }
    HOW_LOG(L_DEBUG, "here");
    // calc p_n_i
    for(int n = 0; n < upperbound * sample_coefficient; n++){
        for(int i = 0; i < upperbound && i <= n; i++){
            // note that n and i here is the same meaning as in the formula
            probability_n_i[n][i] = pow(s, i) * pow(1-s, n-i) * factorial[n] / (factorial[i]*factorial[n-i]);
        }
    }
    HOW_LOG(L_DEBUG, "here");
    // calc X_i and flow_number
    for(int i = 0; i < upperbound; i++){
        total_flow_num += distribution[i];
        iter_flow_num += distribution[i];
    }
    for(int i = upperbound; i < distribution.size(); i++){
        total_flow_num += distribution[i];
    }
    for(int i = 0; i < upperbound; i++){
        fraction_i[i] = distribution[i] / iter_flow_num;
    }
    HOW_LOG(L_DEBUG, "here");
    // calc the new distribution
    for (int __i = 0; __i < iter_num; __i++){
        // note that __i is a var that we don't want it to be used in anywhere
        // the probability of i pkt flow in sample set represent n pkt flow in real set
        vector<vector<double>> probability_i_n(upperbound, vector<double>(upperbound * sample_coefficient)); 
        // double probability_i_n[100][200];
        HOW_LOG(L_DEBUG, "here"); 
        // the total probability of i pkt flow in sample set
        vector<double> probability_i(upperbound, 0);
        HOW_LOG(L_DEBUG, "here");
        // calc p_i
        for(int i = 0; i < upperbound; i++){
            for(int n = i; n < upperbound * sample_coefficient; n++){
                // note that n and i here is the same meaning as in the formula
                probability_i[i] += iter_distribution[n] * probability_n_i[n][i];
            }
        }
        HOW_LOG(L_DEBUG, "here");
        // calc p_i_n
        for(int i = 0; i < upperbound; i++){
            for(int n = i; n < upperbound * sample_coefficient; n++){
                // note that n and i here is the same meaning as in the formula
                probability_i_n[i][n] = iter_distribution[n] * probability_n_i[n][i] / probability_i[i];
            }
        }
        // calc the new distribution
        for(int n = 0; n < upperbound * sample_coefficient; n++){
            double local_n_distribution = 0.0;
            for(int i = 0; i < upperbound && i <= n; i++){
                local_n_distribution += probability_i_n[i][n] * fraction_i[i];
            }
            iter_distribution[n] = local_n_distribution;
        }
        HOW_LOG(L_DEBUG, "here");
        // note that we assume the biggest flow in the real set is twice bigger than the biggest flow in sample set
        double local_total_distribution = 0.0;
        for(int n = 0; n < upperbound * sample_coefficient; n++){
            local_total_distribution += iter_distribution[n];
        }
        // cout << local_total_distribution << endl;
        HOW_LOG(L_INFO, "total distribution before correct: %.2f", local_total_distribution);
        iter_distribution[upperbound * sample_coefficient - 1] += 1-local_total_distribution;
    }
    HOW_LOG(L_DEBUG, "here");
    HOW_LOG(L_DEBUG, "here");
    // the sum of first upperbound flow's distribution is 1
    // so we should scale them to the original proportion
    for(int i = 0; i < upperbound * sample_coefficient; i++){
        new_distribution[i] = iter_distribution[i] * iter_flow_num / total_flow_num;
    }
    // the other flows will be multiple by sample_coefficient
    for(int i = upperbound; i < distribution.size(); i++){
        new_distribution[i*sample_coefficient] = distribution[i];
    }
    for(int i = 0; i < upperbound * sample_coefficient; i++){
        new_distribution[i] *= total_flow_num;
    }
    // distribution.clear();
    // distribution = std::move(new_distribution);
    distribution = new_distribution;
}

void recover_distribution_iter_uponmultiple(vector<double>& distribution, double in_coff, int iter_num){
    // flows has pkts bigger than the upper bound will not included in the iteration
    const int upperbound = 20;
    const int sample_coefficient = static_cast<uint32_t>(in_coff);
    // good-turing
    distribution[0] = distribution[1]*2;
    // the recovered distribution
    vector<double> new_distribution(distribution.size() * sample_coefficient, 0);
    // the distribution involed in the iterations
    vector<double> iter_distribution(upperbound * sample_coefficient, 0);
    // the flows aren't included in the iteration
    // vector<pair<int, double>> bigger_flows();
    // the probability of flow containing n pkt being sampled as i pkt flow
    vector<vector<double>> probability_n_i(upperbound * sample_coefficient, vector<double>(upperbound));  
    // the fraction of i pkt flow in sample set
    vector<double> fraction_i(upperbound, 0);
    double s = 1/in_coff;  // sample rate
    long total_flow_num = 0;  // the total number of flows in the sample set
    long iter_flow_num = 0;  // the number of flows in iterations
    vector<double> factorial(upperbound * sample_coefficient, 0);
    
    // calc factorial
    factorial[0] = 1;
    for(int i = 1; i < upperbound * sample_coefficient; i++){
        factorial[i] = factorial[i-1] * i;
    }
    HOW_LOG(L_DEBUG, "here");
    // calc p_n_i
    for(int n = 0; n < upperbound * sample_coefficient; n++){
        for(int i = 0; i < upperbound && i <= n; i++){
            // note that n and i here is the same meaning as in the formula
            probability_n_i[n][i] = pow(s, i) * pow(1-s, n-i) * factorial[n] / (factorial[i]*factorial[n-i]);
        }
    }
    HOW_LOG(L_DEBUG, "here");
    // calc X_i and flow_number
    for(int i = 0; i < upperbound; i++){
        total_flow_num += distribution[i];
        iter_flow_num += distribution[i];
    }
    for(int i = upperbound; i < distribution.size(); i++){
        total_flow_num += distribution[i];
    }
    for(int i = 0; i < upperbound; i++){
        fraction_i[i] = distribution[i] / iter_flow_num;
    }
    // build the initial distribution by multiple
    for(int i = 0; i < upperbound; ++i){
        // number of even numbers in the gap of the sample_coefficient
        const int even_num = sample_coefficient/2;
        for(int j = 0; j < even_num; j++){
            iter_distribution[i*sample_coefficient + j*2] += distribution[i] / even_num; 
        }
    }
    HOW_LOG(L_DEBUG, "here");
    // calc the new distribution
    for (int __i = 0; __i < iter_num; __i++){
        // note that __i is a var that we don't want it to be used in anywhere
        // the probability of i pkt flow in sample set represent n pkt flow in real set
        vector<vector<double>> probability_i_n(upperbound, vector<double>(upperbound * sample_coefficient)); 
        // double probability_i_n[100][200];
        HOW_LOG(L_DEBUG, "here"); 
        // the total probability of i pkt flow in sample set
        vector<double> probability_i(upperbound, 0);
        HOW_LOG(L_DEBUG, "here");
        // calc p_i
        for(int i = 0; i < upperbound; i++){
            for(int n = i; n < upperbound * sample_coefficient; n++){
                // note that n and i here is the same meaning as in the formula
                probability_i[i] += iter_distribution[n] * probability_n_i[n][i];
            }
        }
        HOW_LOG(L_DEBUG, "here");
        // calc p_i_n
        for(int i = 0; i < upperbound; i++){
            for(int n = i; n < upperbound * sample_coefficient; n++){
                // note that n and i here is the same meaning as in the formula
                probability_i_n[i][n] = iter_distribution[n] * probability_n_i[n][i] / probability_i[i];
            }
        }
        // calc the new distribution
        for(int n = 0; n < upperbound * sample_coefficient; n++){
            double local_n_distribution = 0.0;
            for(int i = 0; i < upperbound && i <= n; i++){
                local_n_distribution += probability_i_n[i][n] * fraction_i[i];
            }
            iter_distribution[n] = local_n_distribution;
        }
        HOW_LOG(L_DEBUG, "here");
        // note that we assume the biggest flow in the real set is twice bigger than the biggest flow in sample set
        double local_total_distribution = 0.0;
        for(int n = 0; n < upperbound * sample_coefficient; n++){
            local_total_distribution += iter_distribution[n];
        }
        // cout << local_total_distribution << endl;
        HOW_LOG(L_INFO, "total distribution before correct: %.2f", local_total_distribution);
        iter_distribution[upperbound * sample_coefficient - 1] += 1-local_total_distribution;
    }
    HOW_LOG(L_DEBUG, "here");
    // the sum of first upperbound flow's distribution is 1
    // so we should scale them to the original proportion
    for(int i = 0; i < upperbound * sample_coefficient; i++){
        new_distribution[i] = iter_distribution[i] * iter_flow_num / total_flow_num;
    }
    // the other flows will be multiple by sample_coefficient
    for(int i = upperbound; i < distribution.size(); i++){
        new_distribution[i*sample_coefficient] = distribution[i];
    }
    for(int i = 0; i < upperbound * sample_coefficient; i++){
        new_distribution[i] *= total_flow_num;
    }
    // distribution.clear();
    // distribution = std::move(new_distribution);
    distribution = new_distribution;
}

void recover_distribution_simple(vector<double>& distribution, double in_coff){
    vector<double> new_distribution(distribution.size() * in_coff, 0);
    for(int i=0; i<distribution.size(); ++i){
        uint32_t new_idx = static_cast<uint32_t>(i * in_coff);
        new_distribution[new_idx] = distribution[i];
    }
    distribution = new_distribution;
}

void recover_distribution_simple4(vector<double>& distribution, double in_coff){
    vector<double> new_distribution(distribution.size() * in_coff, 0);
    for(int i=1; i<distribution.size(); ++i){
        uint32_t new_idx = static_cast<uint32_t>(i * in_coff);
        new_distribution[new_idx] = distribution[i]/2;
        new_idx = static_cast<uint32_t>(i * in_coff-2);
        new_distribution[new_idx] = distribution[i]/2;
    }
    distribution = new_distribution;
}

void recover_distribution2(vector<double>& distribution, double in_coff){
    vector<double> new_distribution(distribution.size() * in_coff, 0);
    for(int i=0; i<distribution.size(); ++i){
        uint32_t new_idx = static_cast<uint32_t>(i * in_coff);
        new_distribution[i] += distribution[i];
        new_distribution[new_idx] += distribution[i] / in_coff;
    }
    distribution = new_distribution;
}

double measure_main(DataTrace& trace, Manager& tbc_manager){
    FTupleMatch* filter = new FTupleMatch("*.*.*.*", "*.*.*.*", "*", "*", "*");
    int hll_task_id = tbc_manager.allocate_mrachll(m, n, coin_level, filter, ACTION_SET_KEY_IPPAIR, ACTION_SET_VAL_IPPAIR);
    if(hll_task_id < 0) {
        return -1;
    }
    unordered_map<string, int> Real_Freq;
    unordered_map<string, int> TBC_Gt;
    uint32_t max_size = 0;
    for (auto it=trace.begin(); it!=trace.end(); ++it){
        tbc_manager.apply(*it);
        string str((const char*)((*it)->getFlowKey_IPPair()), 8);
        Real_Freq[str]++;
        
    } 
    map<uint32_t, map<uint32_t, vector<uint32_t>>> mrac_hll_sketch;
    tbc_manager.query(hll_task_id, mrac_hll_sketch);
    tbc_manager.getTaskStatistics(hll_task_id, TBC_Gt);
    auto& hll_data = mrac_hll_sketch[0][0];
    auto& mrac_data = mrac_hll_sketch[0][1];
    uint32_t estimate_distinct = HyperLogLogCalc(hll_data);

    vector<double> dist_groundtruth;
    vector<double> dist_sampled_simple;  // sampled distribution always true.
    vector<double> dist_sampled_zzc;  // sampled distribution always true.
    vector<double> dist_sampled_zzc_indenpendent;  // sampled distribution always true.
    vector<double> dist_sampled_mrac;  // sample distribution from mrac.
    // get ground truth distribution.
    dist_groundtruth.resize(get_max(Real_Freq)+1, 0);
    for(auto& flow : Real_Freq){
        dist_groundtruth[flow.second] += 1;
    }
    // get dist sampled.
    dist_sampled_simple.resize(get_max(TBC_Gt)+1, 0);
    dist_sampled_zzc.resize(get_max(TBC_Gt)+1, 0);
    dist_sampled_zzc_indenpendent.resize(get_max(TBC_Gt)+1, 0);
    for(auto& flow : TBC_Gt){
        dist_sampled_simple[flow.second] += 1;
        dist_sampled_zzc[flow.second] += 1;
        dist_sampled_zzc_indenpendent[flow.second] += 1;
    }

    uint32_t test_real_distinct = Real_Freq.size();
    uint32_t test_samp_distinct = TBC_Gt.size();
    uint32_t test_samp_once = dist_sampled_simple[1];
    uint32_t l = 0;
    for(auto& item : TBC_Gt){
        l += item.second;
    }
    double P0 = static_cast<double>(test_samp_once) / l;
    double fixed_estimate_distinct = (1/(1-P0)) * estimate_distinct;

    HOW_LOG(L_INFO, "Distinct Real : %d, HLL Original: %.2f, Estimate: %.2f.", 
                     test_real_distinct, 
                     estimate_distinct,
                     fixed_estimate_distinct);
    delete filter;
    return 0;
}


int main(int argc, char* argv[]){
    clock_t start = clock();
    DataTrace trace;
    // trace.LoadFromFile("../data/WIDE/one_sec_15.dat");
    // trace.LoadFromFile("../data/WIDE/head1000.dat");
    // trace.LoadFromFile("../data/WIDE/test.dat");
    // trace.LoadFromFile("../data/WIDE/ten_sec_1.dat");
    trace.LoadFromFile("../data/WIDE/fifteen1.dat");
    auto& tbc_manager = Manager::getDataplane();
    measure_main(trace, tbc_manager);
    clock_t ends = clock();
    cout <<"Running Time : "<<(double)(ends - start)/ CLOCKS_PER_SEC << endl;
}